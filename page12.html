<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>drift::gather</title>
  <style>
    body {
      overflow: hidden;
      background: #000;
      color: #e6e6e6;
      margin: 0;
    }
    #particleCanvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1;
    }

    .word {
      position: absolute;
      color: #ffffffdd;
      font-family: "Courier New", monospace;
      font-size: 22px;
      opacity: 0;
      transition: opacity 0.8s ease;
      pointer-events: none;
      text-shadow: 0 0 8px #ffffff88;
      z-index: 5;
    }

    #fadeBlack {
      position: fixed;
      inset: 0;
      background: #000;
      opacity: 0;
      transition: opacity 2s ease;
      pointer-events: none;
      z-index: 5;
    }

    .supernova-glow {
      position: absolute;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.7) 0%, rgba(255,255,255,0.3) 30%, rgba(255,255,255,0) 60%);
      pointer-events: none;
      z-index: 4;
      opacity: 0;
      transform: translate(-50%, -50%) scale(0.3);
    }
  </style>
</head>
<body>
  <canvas id="particleCanvas" aria-hidden="true"></canvas>
  <div id="fadeBlack"></div>

  <script>
    const canvas = document.getElementById('particleCanvas');
    const ctx = canvas.getContext('2d');

    const fadeBlack = document.getElementById('fadeBlack');

    const symbols = ['*','@','#','~','+','%','&','?',';',':'];

    // dense field
    const particleCount = 550;
    const particles = [];

    let mouse = { x: 0, y: 0, active: false };

    let hotspots = [];
    let lockedHotspots = [];
    let allHotspotsLocked = false;

    const collapsed = [false, false, false, false, false]; // per galaxy
    const revealWords = ["you", "wander", "into", "her", "soul"];
    let clickWordIndex = 0; // sequence of user clicks -> word order
    let allWordsRevealed = false;

    // audio
    let audioCtx = null;
    let masterGain = null;

    function ensureAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.35;
        masterGain.connect(audioCtx.destination);
      }
      if (audioCtx.state === "suspended") {
        audioCtx.resume().catch(() => {});
      }
    }

    function playLockTwinkle() {
      ensureAudio();
      const now = audioCtx.currentTime;
      const lockVolume = 0.6; // overall trim for lock-in sfx

      // Reverb path with slight variation per strike
      const reverbDelay = audioCtx.createDelay();
      reverbDelay.delayTime.value = 0.18 + Math.random() * 0.14;
      const reverbFilter = audioCtx.createBiquadFilter();
      reverbFilter.type = 'lowpass';
      reverbFilter.frequency.value = 3200;
      const reverbGain = audioCtx.createGain();
      const reverbTail = 1.2 + Math.random() * 0.8; // 1.2â€“2.0s tail
      reverbGain.gain.setValueAtTime(0.05 * lockVolume, now);
      reverbGain.gain.exponentialRampToValueAtTime(0.0001, now + reverbTail);
      reverbDelay.connect(reverbFilter).connect(reverbGain).connect(masterGain);

      // Base pitch variation
      const pitchMult = 0.85 + Math.random() * 0.3;

      // Randomize which frequencies play (not all 5 every time)
      const allHighs = [4113, 4156, 4177, 4199, 4221];
      const allLows = [215, 237, 258, 280];

      // Pick 2-4 random highs and 1-3 random lows
      const highFreqs = allHighs.filter(() => Math.random() > 0.3);
      const lowFreqs = allLows.filter(() => Math.random() > 0.4);

      // Randomize timing
      const secondHitDelay = 0.35 + Math.random() * 0.25; // 350-600ms
      const hasSecondHit = Math.random() > 0.3; // 70% chance of second strike

      // Randomize decay time
      const decayTime = 1.0 + Math.random() * 1.0; // 1-2 seconds

      // First strike - highs
      highFreqs.forEach(freq => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sine';
        // More detune variation per oscillator
        osc.frequency.value = freq * pitchMult * (0.94 + Math.random() * 0.12);
        const stopTime = now + decayTime + 0.3;
        gain.gain.setValueAtTime((0.06 + Math.random() * 0.04) * lockVolume, now);
        gain.gain.exponentialRampToValueAtTime(0.001, stopTime - 0.06);
        gain.gain.linearRampToValueAtTime(0.0001, stopTime);
        osc.connect(gain).connect(masterGain);
        osc.connect(reverbDelay);
        osc.start(now);
        osc.stop(stopTime);
      });

      // First strike - low body (sometimes skip entirely)
      if (Math.random() > 0.2) {
        lowFreqs.forEach(freq => {
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = 'sine';
          osc.frequency.value = freq * pitchMult;
          const lowStop = now + 0.6;
          gain.gain.setValueAtTime((0.03 + Math.random() * 0.03) * lockVolume, now);
          gain.gain.exponentialRampToValueAtTime(0.001, lowStop - 0.08);
          gain.gain.linearRampToValueAtTime(0.0001, lowStop);
          osc.connect(gain).connect(masterGain);
          osc.connect(reverbDelay);
          osc.start(now);
          osc.stop(lowStop);
        });
      }

      // Second strike (not always)
      if (hasSecondHit) {
        const secondHit = now + secondHitDelay;
        // Pick different subset for second hit
        const secondHighs = allHighs.filter(() => Math.random() > 0.4);

        secondHighs.forEach(freq => {
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = 'sine';
          osc.frequency.value = freq * pitchMult * (0.94 + Math.random() * 0.12);
          const secondStop = secondHit + decayTime + 0.25;
          gain.gain.setValueAtTime(0, now);
          gain.gain.setValueAtTime((0.08 + Math.random() * 0.06) * lockVolume, secondHit);
          gain.gain.exponentialRampToValueAtTime(0.001, secondStop - 0.08);
          gain.gain.linearRampToValueAtTime(0.0001, secondStop);
          osc.connect(gain).connect(masterGain);
          osc.connect(reverbDelay);
          osc.start(now);
          osc.stop(secondStop);
        });
      }

      // Occasional third tiny hit (20% chance)
    if (Math.random() > 0.8) {
      const thirdHit = now + secondHitDelay + 0.2 + Math.random() * 0.3;
    const freq = allHighs[Math.floor(Math.random() * allHighs.length)];
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.value = freq * pitchMult * (0.9 + Math.random() * 0.2);
    const thirdStop = thirdHit + 0.85;
    gain.gain.setValueAtTime(0, now);
    gain.gain.setValueAtTime(0.04 * lockVolume, thirdHit);
    gain.gain.exponentialRampToValueAtTime(0.001, thirdStop - 0.08);
    gain.gain.linearRampToValueAtTime(0.0001, thirdStop);
    osc.connect(gain).connect(masterGain);
    osc.connect(reverbDelay);
    osc.start(now);
    osc.stop(thirdStop);
  }
  }

    function playCollapseWhump() {
      ensureAudio();
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      osc.type = "sine";
      osc.frequency.setValueAtTime(70, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(32, audioCtx.currentTime + 0.25);
      filter.type = "lowpass";
      filter.frequency.setValueAtTime(360, audioCtx.currentTime);
      filter.frequency.exponentialRampToValueAtTime(140, audioCtx.currentTime + 0.22);
      gain.gain.setValueAtTime(0.28, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.45);
      osc.connect(filter).connect(gain).connect(masterGain);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.5);
    }

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      // Constellation layout
      hotspots = [
        { x: canvas.width * 0.18, y: canvas.height * 0.30 }, // upper-left
        { x: canvas.width * 0.26, y: canvas.height * 0.82 }, // lower-left
        { x: canvas.width * 0.50, y: canvas.height * 0.50 }, // center
        { x: canvas.width * 0.73, y: canvas.height * 0.65 }, // mid-right lower
        { x: canvas.width * 0.82, y: canvas.height * 0.18 }  // upper-right
      ];

      lockedHotspots = hotspots.map((_, i) => lockedHotspots[i] || false);
      allHotspotsLocked = lockedHotspots.every(Boolean);
    }

    function createParticles() {
      particles.length = 0;
      for (let i = 0; i < particleCount; i++) {
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          // Very slow initial velocity - like distant stars
          vx: (Math.random() - 0.5) * 0.08,
          vy: (Math.random() - 0.5) * 0.08,
          char: symbols[Math.floor(Math.random() * symbols.length)],
          size: 8 + Math.random() * 4,
          pulse: Math.random() * Math.PI * 2,

          // Per-particle personality - gentler values for idle, still varied for gravity
          driftStrength: 0.002 + Math.random() * 0.004, // very gentle drift
          gravityResponse: 0.4 + Math.random() * 1.2, // keep varied for pulls
          noiseOffsetX: Math.random() * 1000,
          noiseOffsetY: Math.random() * 1000,

          locked: false,
          lockedIndex: null,
          orbitRadius: 0,
          targetOrbitRadius: 0,
          orbitAngle: Math.random() * Math.PI * 2,
          orbitSpeed: 0.0005 + Math.random() * 0.002,
          orbitEccentricity: 0.3 + Math.random() * 0.5,
          orbitTilt: Math.random() * Math.PI * 2,
          radialDrift: (Math.random() - 0.5) * 0.02,
          lockTransition: 0,

          collapsing: false,
          fadeProgress: 1,
          targetX: null,
          targetY: null
        });
      }
    }

    function drawParticle(p, time, pulseBoost) {
      const pulse = Math.sin(time / 450 + p.pulse) * 0.7;
      const size = p.size + pulse + pulseBoost;
      ctx.font = `${size.toFixed(2)}px "Courier New", monospace`;
      ctx.fillStyle = `rgba(255,255,255,${p.fadeProgress})`;
      ctx.fillText(p.char, p.x, p.y);
    }

    // Smooth noise-based drift - very gentle for star-like floating
    function addIdleDrift(p, time) {
      if (p.locked || allHotspotsLocked || p.collapsing) return;

      // Very slow-moving noise for gentle stellar drift
      const t = time * 0.00003; // much slower
      const noiseX = Math.sin(t + p.noiseOffsetX) * Math.cos(t * 0.7 + p.noiseOffsetY);
      const noiseY = Math.cos(t + p.noiseOffsetY) * Math.sin(t * 0.6 + p.noiseOffsetX);

      p.vx += noiseX * p.driftStrength * 0.15; // much gentler
      p.vy += noiseY * p.driftStrength * 0.15;
    }

    // Ensure particles maintain minimum velocity - very subtle for stars
    function maintainMinimumVelocity(p) {
      if (p.locked || p.collapsing) return;
      const speed = Math.hypot(p.vx, p.vy);
      // Very low minimum - stars can almost hover
      const minSpeed = 0.01;
      if (speed < minSpeed) {
        const angle = p.noiseOffsetX + performance.now() * 0.00005;
        p.vx += Math.cos(angle) * 0.005;
        p.vy += Math.sin(angle) * 0.005;
      }
      // Cap maximum speed - still allow fast movement when pulled
      const maxSpeed = 0.4 + p.gravityResponse * 0.2;
      if (speed > maxSpeed) {
        p.vx = (p.vx / speed) * maxSpeed;
        p.vy = (p.vy / speed) * maxSpeed;
      }
    }

    // Diffusion - only really kicks in when crowded from being pulled together
    function applyDiffusion(p, particles) {
      if (p.locked || p.collapsing) return;
      let nearbyCount = 0;
      for (const other of particles) {
        if (other === p || other.locked || other.collapsing) continue;
        const dx = p.x - other.x;
        const dy = p.y - other.y;
        const dist = Math.hypot(dx, dy);
        if (dist < 25 && dist > 0.1) { // tighter radius
          nearbyCount++;
          // Only apply diffusion if actually crowded
          if (nearbyCount > 2) {
            const force = (25 - dist) / 25 * 0.004 * p.gravityResponse;
            p.vx += (dx / dist) * force;
            p.vy += (dy / dist) * force;
          }
        }
      }
      // Extra push only if very crowded
      if (nearbyCount > 6) {
        const angle = Math.random() * Math.PI * 2;
        p.vx += Math.cos(angle) * 0.02;
        p.vy += Math.sin(angle) * 0.02;
      }
    }

    // subtle repulsion
    function repelFromMouse(p) {
      if (!mouse.active || allHotspotsLocked || p.collapsing) return;
      const dx = p.x - mouse.x;
      const dy = p.y - mouse.y;
      const dist = Math.hypot(dx, dy);
      const influence = 70;
      if (dist < influence && dist > 0.01) {
        const force = (influence - dist) / influence * 0.04;
        p.vx += (dx / dist) * force;
        p.vy += (dy / dist) * force;
      }
    }

    function bundleTowardsHotspot(p, activeHotspots, time) {
      let pulseBoost = 0;
      for (const h of activeHotspots) {
        const dx = h.x - p.x;
        const dy = h.y - p.y;
        const dist = Math.hypot(dx, dy) || 1;
        const pullRadius = 200;
        if (dist < pullRadius) {
          // Pulsing gravity strength
          const gravityPulse = 1 + Math.sin(time * 0.003 + h.index) * 0.3;
          // Per-particle response varies
          const baseAttraction = (pullRadius - dist) / pullRadius * 0.06;
          const attraction = baseAttraction * p.gravityResponse * gravityPulse;

          // Add slight tangential swirl for more organic gathering
          const tangentX = -dy / dist;
          const tangentY = dx / dist;
          const swirlStrength = 0.015 * (1 - dist / pullRadius);

          p.vx += (dx / dist) * attraction + tangentX * swirlStrength;
          p.vy += (dy / dist) * attraction + tangentY * swirlStrength;
          pulseBoost = Math.max(pulseBoost, 2 * gravityPulse);
        }
      }
      return pulseBoost;
    }

    function twirlAroundHotspot(p, time) {
      const target = hotspots[p.lockedIndex];
      if (!target) return;

      // Smoothly transition into orbit
      if (p.lockTransition < 1) {
        p.lockTransition += 0.02; // gradual transition
        if (p.lockTransition > 1) p.lockTransition = 1;
      }

      // Smoothly expand orbit radius to target
      p.orbitRadius += (p.targetOrbitRadius - p.orbitRadius) * 0.03;

      p.orbitAngle += p.orbitSpeed;

      // Slow radial drift - particles migrate in and out
      p.targetOrbitRadius += p.radialDrift;
      // Constrain radius so they don't drift too far
      if (p.targetOrbitRadius < 15) {
        p.targetOrbitRadius = 15;
        p.radialDrift = Math.abs(p.radialDrift) * 0.5;
      }
      if (p.targetOrbitRadius > 110) {
        p.targetOrbitRadius = 110;
        p.radialDrift = -Math.abs(p.radialDrift) * 0.5;
      }

      // Gentle breathing wobble
      const wobble = Math.sin(time / 1200 + p.pulse) * 3;

      // Elliptical orbit calculation
      const ellipseX = Math.cos(p.orbitAngle) * p.orbitRadius;
      const ellipseY = Math.sin(p.orbitAngle) * p.orbitRadius * p.orbitEccentricity;

      // Rotate the ellipse by the tilt angle
      const rotatedX = ellipseX * Math.cos(p.orbitTilt) - ellipseY * Math.sin(p.orbitTilt);
      const rotatedY = ellipseX * Math.sin(p.orbitTilt) + ellipseY * Math.cos(p.orbitTilt);

      // Target position in orbit
      const orbitX = target.x + rotatedX + wobble * Math.cos(time / 800 + p.pulse);
      const orbitY = target.y + rotatedY + wobble * Math.sin(time / 800 + p.pulse);

      // Blend from current position to orbit position based on transition
      p.x = p.x + (orbitX - p.x) * (0.02 + p.lockTransition * 0.03);
      p.y = p.y + (orbitY - p.y) * (0.02 + p.lockTransition * 0.03);

      drawParticle(p, time, 2.0);
    }

    function showWord(word, baseX, baseY) {
      const el = document.createElement("div");
      el.className = "word";
      el.textContent = word;

      // center-ish offset based on word length
      const offsetX = word.length * 6;
      el.style.left = `${baseX - offsetX}px`;
      el.style.top = `${baseY - 10}px`;

      document.body.appendChild(el);

      requestAnimationFrame(() => {
        el.style.opacity = "1";
      });
    }

    function createSupernovaGlow(x, y, word) {
      const glow = document.createElement("div");
      glow.className = "supernova-glow";
      glow.style.left = `${x}px`;
      glow.style.top = `${y}px`;
      glow.style.width = "80px";
      glow.style.height = "80px";
      document.body.appendChild(glow);

      // Show word immediately with the glow
      showWord(word, x, y);

      // Phase 1: gentle expansion and brighten
      requestAnimationFrame(() => {
        glow.style.transition = "opacity 0.2s ease-out, transform 0.2s ease-out";
        glow.style.opacity = "1";
        glow.style.transform = "translate(-50%, -50%) scale(1)";
      });

      // Phase 2: fade out glow, word remains
      setTimeout(() => {
        glow.style.transition = "opacity 1s ease-in";
        glow.style.opacity = "0";
      }, 300);

      // Phase 3: remove glow element
      setTimeout(() => {
        glow.remove();
      }, 1300);
    }

function collapseGalaxy(index) {
  if (collapsed[index]) return;
  if (clickWordIndex >= revealWords.length) return;

  collapsed[index] = true;
  playCollapseWhump();

  const word = revealWords[clickWordIndex];
  clickWordIndex++;

      const center = hotspots[index];

      // Mark particles for fast inward collapse
      for (const p of particles) {
        if (p.lockedIndex === index && !p.collapsing) {
          p.collapsing = true;
          p.locked = false;
          p.collapseSpeed = 0.08 + Math.random() * 0.06;
          p.targetX = center.x;
          p.targetY = center.y;
        }
      }

      // Delay the supernova until particles have rushed inward
      setTimeout(() => {
        createSupernovaGlow(center.x, center.y, word);
      }, 400);

      // If all galaxies collapsed, trigger the final sequence
      if (collapsed.every(Boolean) && !allWordsRevealed) {
        triggerFinalFadeSequence();
      }
    }

    function triggerFinalFadeSequence() {
      allWordsRevealed = true;

      // wait 2s after last word (1s for glow + 1s hold)
      setTimeout(() => {
        // Fade out all words
        const words = document.querySelectorAll('.word');
        words.forEach(w => {
          w.style.transition = "opacity 2s ease";
          w.style.opacity = "0";
        });

        fadeBlack.style.opacity = "1";
      }, 2000);

      // after black fully up, go to page14
      setTimeout(() => {
        window.location.href = "page14.html";
      }, 4500);
    }

    function update() {
      const now = performance.now();
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const activeHotspots =
        !allHotspotsLocked && mouse.active
          ? hotspots
              .map((h, i) => ({ ...h, index: i }))
              .filter(({ x, y, index }) => {
                if (lockedHotspots[index]) return false;
                const dist = Math.hypot(x - mouse.x, y - mouse.y);
                return dist < 100;
              })
          : [];

      for (const p of particles) {
        // collapsing into supernova
        if (p.collapsing) {
          if (p.targetX != null && p.targetY != null) {
            // Fast inward rush - accelerating
            const dx = p.targetX - p.x;
            const dy = p.targetY - p.y;
            const dist = Math.hypot(dx, dy);

            // Accelerate as they get closer
            const speed = p.collapseSpeed || 0.1;
            p.x += dx * speed;
            p.y += dy * speed;

            // Fade out as they converge
            if (dist < 50) {
              p.fadeProgress *= 0.92;
            } else {
              p.fadeProgress *= 0.98;
            }
          }

          drawParticle(p, now, 0);
          continue;
        }

        if (p.locked) {
          twirlAroundHotspot(p, now);
          continue;
        }

        if (allHotspotsLocked) {
          // background: hold & drift slowly, don't disappear
          p.vx *= 0.985;
          p.vy *= 0.985;
          p.vx += (Math.random() - 0.5) * 0.004;
          p.vy += (Math.random() - 0.5) * 0.004;
        } else {
          // Always add gentle drift
          addIdleDrift(p, now);
          repelFromMouse(p);
          applyDiffusion(p, particles);
          const pulseBoost = bundleTowardsHotspot(p, activeHotspots, now);

          p.x += p.vx;
          p.y += p.vy;

          if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
          if (p.y < 0 || p.y > canvas.height) p.vy *= -1;

          p.x = Math.max(0, Math.min(canvas.width, p.x));
          p.y = Math.max(0, Math.min(canvas.height, p.y));

          // Stronger damping for calmer movement
          const damping = 0.985;
          p.vx *= damping;
          p.vy *= damping;

          // Keep movement going but capped
          maintainMinimumVelocity(p);

          drawParticle(p, now, pulseBoost);
          continue;
        }

        // free-floating background in the post-formation phase
        p.x += p.vx;
        p.y += p.vy;

        p.x = Math.max(0, Math.min(canvas.width, p.x));
        p.y = Math.max(0, Math.min(canvas.height, p.y));

        drawParticle(p, now, 0);
      }

      requestAnimationFrame(update);
    }

    canvas.addEventListener('mousemove', (e) => {
      const r = canvas.getBoundingClientRect();
      mouse = {
        x: e.clientX - r.left,
        y: e.clientY - r.top,
        active: true
      };

      // Show pointer cursor when hovering over clickable galaxies
      if (allHotspotsLocked) {
        let overGalaxy = false;
        for (let i = 0; i < hotspots.length; i++) {
          if (collapsed[i]) continue;
          const h = hotspots[i];
          const dist = Math.hypot(h.x - mouse.x, h.y - mouse.y);
          if (dist < 60) {
            overGalaxy = true;
            break;
          }
        }
        canvas.style.cursor = overGalaxy ? 'pointer' : 'default';
      }
    });

    canvas.addEventListener('mouseleave', () => {
      mouse.active = false;
    });

    function findTargetHotspot(position) {
      let candidate = null;
      hotspots.forEach((h, index) => {
        if (lockedHotspots[index]) return;
        const dist = Math.hypot(h.x - position.x, h.y - position.y);
        if (dist < 140 && (!candidate || dist < candidate.dist)) {
          candidate = { index, dist };
        }
      });
      return candidate;
    }

    function lockParticlesToHotspot(targetIndex) {
      if (lockedHotspots[targetIndex]) return;
      const target = hotspots[targetIndex];
      if (!target) return;

      lockedHotspots[targetIndex] = true;
      const lockRadius = 180;
      let lockedAny = false;

      for (const p of particles) {
        const dx = p.x - target.x;
        const dy = p.y - target.y;
        const dist = Math.hypot(dx, dy);
        if (!p.locked && dist < lockRadius) {
          p.locked = true;
          p.lockedIndex = targetIndex;

          // Start orbit radius at current distance from center
          p.orbitRadius = Math.max(5, dist);

          // Target radius - varied, biased toward center
          const radiusFactor = Math.random() * Math.random();
          p.targetOrbitRadius = 15 + radiusFactor * 95;

          // Start angle from current position
          p.orbitAngle = Math.atan2(dy, dx);
          p.orbitSpeed = 0.0003 + Math.random() * 0.0025;
          p.orbitEccentricity = 0.4 + Math.random() * 0.5;
          p.orbitTilt = Math.random() * Math.PI * 2;
          p.radialDrift = (Math.random() - 0.5) * 0.015;
          p.lockTransition = 0; // start transition

          p.vx = 0;
          p.vy = 0;
          lockedAny = true;
        }
      }

      if (lockedAny) {
        playLockTwinkle();
      }

      if (lockedHotspots.every(Boolean)) {
        allHotspotsLocked = true;
      }
    }

    canvas.addEventListener('click', (e) => {
      const r = canvas.getBoundingClientRect();
      const pos = { x: e.clientX - r.left, y: e.clientY - r.top };

      if (!allHotspotsLocked) {
        // still forming galaxies
        const target = findTargetHotspot(pos);
        if (target) lockParticlesToHotspot(target.index);
        return;
      }

      // all galaxies formed: clicks collapse them into words (in click order)
      hotspots.forEach((h, i) => {
        if (collapsed[i]) return;
        const dist = Math.hypot(h.x - pos.x, h.y - pos.y);
        if (dist < 60) {
          collapseGalaxy(i);
        }
      });
    });

    window.addEventListener('resize', () => {
      resize();
      createParticles();
    });

    resize();
    createParticles();
    update();
  </script>
</body>
</html>
