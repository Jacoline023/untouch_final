<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>touch</title>

<style>
    body {
        margin: 0;
        padding: 0;
        background: #000000;
        color: #f5f5f5;
        font-family: "Courier New", monospace;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
    }

    #wrapper {
        text-align: center;
        white-space: pre;
        font-size: 18px;
        line-height: 1.6;
        width: 100%;
    }

    .choice {
        cursor: pointer;
        display: inline-block;
        margin: 0 40px;
        padding: 4px 10px;
        transition: opacity 0.3s ease;
    }
    .choice:hover {
        opacity: 0.7;
        text-decoration: underline;
    }
    .choice.disabled {
        pointer-events: none;
        opacity: 0.3;
        cursor: default;
        text-decoration: none;
    }

    #output {
        margin: 40px auto 0 auto;
        font-size: 15px;
        white-space: pre-wrap;
        text-align: left;
        display: inline-block;
        width: 80%;
        max-width: 760px;
        padding: 18px 22px;
        background: rgba(0, 0, 0, 0.65);
        min-height: 200px;
        max-height: 65vh;
        overflow-y: auto;
    }

    /* terminal colors */
    .green { color: #33FF33; }
    .yellow { color: #E6E67A; }
    .red { color: #FF5555; }

    /* blinking cursor */
    #cursor {
        display: none;
        width: 0.65em;
        height: 1em;
        background: #f5f5f5;
        animation: blink 0.6s steps(2, start) infinite;
        vertical-align: bottom;
    }

    @keyframes blink {
        to { visibility: hidden; }
    }

    /* terminal input */
    .prompt-line {
        display: flex;
        align-items: center;
    }
    
    .prompt-symbol {
        color: #f5f5f5;
        margin-right: 0;
    }
    
    #terminal-input {
        background: transparent;
        border: none;
        outline: none;
        color: #f5f5f5;
        font-family: "Courier New", monospace;
        font-size: 15px;
        width: 200px;
        caret-color: #f5f5f5;
    }
    
    #terminal-input.error {
        animation: flash-red 0.15s ease 2;
    }
    
    @keyframes flash-red {
        0%, 100% { background: transparent; }
        50% { background: rgba(255, 85, 85, 0.4); }
    }
</style>
</head>

<body>

<div id="wrapper">

-> <span class="choice" id="choice-her">her</span>
-> <span class="choice" id="choice-him">him</span>

<div id="output"></div>
<div id="cursor"></div>

</div>

<script>
const out = document.getElementById("output");
const cursor = document.getElementById("cursor");
let locked = false;
let audioCtx = null;
let typingSoundInterval = null;
let charDelayScale = 1;
let typingGainScale = 1;
let typingFreqBase = 620;
let typingFreqJitter = 20;
let pitchDropActive = false;
let pitchDropOffset = 0;
let glitchBedSource = null;
let glitchBedGain = null;
let glitchRingOsc = null;
let glitchRingGain = null;
let glitchRingLfo = null;
let glitchRingLfoGain = null;
let glitchBedLfo = null;
let glitchBedLfoGain = null;

const softHerLines = new Set([
    "i am not the one you seek",
    "but i can hold your longing",
    "for a while",
    "she exists without you",
    "is it she that loves you,",
    'or an entity defined by "love"?'
]);
const softPauseRange = [800, 1300]; // ms of hesitation around soft section

function ensureAudio() {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioCtx.state === "suspended") {
        audioCtx.resume().catch(() => {});
    }
}

function playClickSound() {
    ensureAudio();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();
    osc.type = "square";
    osc.frequency.value = 420 + Math.random() * 80; // softer click
    gain.gain.value = 0.04;
    filter.type = "lowpass";
    filter.frequency.value = 1400;
    osc.connect(filter).connect(gain).connect(audioCtx.destination);
    osc.start();
    gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.08);
    osc.stop(audioCtx.currentTime + 0.1);
}

function playOkChirp() {
    ensureAudio();
    const now = audioCtx.currentTime;

    const chirp = (start, freq) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = "square";
        osc.frequency.value = freq; // sharp, 8-bit style
        gain.gain.setValueAtTime(0.0001, start);
        gain.gain.exponentialRampToValueAtTime(0.12, start + 0.01); // slightly quieter
        gain.gain.exponentialRampToValueAtTime(0.0001, start + 0.07);
        osc.connect(gain).connect(audioCtx.destination);
        osc.start(start);
        osc.stop(start + 0.09);
    };

    // One-shot double chirp ~0.3s total
    chirp(now, 2100);
    chirp(now + 0.14, 2500);
}

function playErrorBuzz() {
    ensureAudio();
    const now = audioCtx.currentTime;

    const firePulse = (start) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();
        osc.type = "sawtooth";
        osc.frequency.value = 60; // deeper buzz
        osc.detune.setValueAtTime(240, start); // keep bite/aliasing

        // mild waveshaping for distortion
        const shaper = audioCtx.createWaveShaper();
        const curve = new Float32Array(512);
        for (let i = 0; i < curve.length; i++) {
            const x = (i / (curve.length - 1)) * 2 - 1;
            curve[i] = Math.tanh(6 * x);
        }
        shaper.curve = curve;
        shaper.oversample = "4x";

        gain.gain.setValueAtTime(0.0001, start);
        const peak = pitchDropActive ? 0.6 : 0.42; // louder during drop
        gain.gain.exponentialRampToValueAtTime(peak, start + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.0001, start + 0.22);

        filter.type = "bandpass";
        filter.frequency.setValueAtTime(680, start);
        filter.Q.value = 1.6;

        osc.connect(shaper).connect(filter).connect(gain).connect(audioCtx.destination);
        osc.start(start);
        osc.stop(start + 0.24);
    };

    firePulse(now);
    firePulse(now + 0.16); // double harsh buzz
}

function startGlitchBed() {
    ensureAudio();
    if (glitchBedSource) return;

    const noiseDur = 2.0;
    const buffer = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate * noiseDur), audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
        // smoother noise bed, no spikes
        data[i] = (Math.random() * 0.12 - 0.06);
    }

    const source = audioCtx.createBufferSource();
    source.buffer = buffer;
    source.loop = true;

    const filter = audioCtx.createBiquadFilter();
    filter.type = "bandpass";
    filter.frequency.value = 620;
    filter.Q.value = 0.12;

    const shelf = audioCtx.createBiquadFilter();
    shelf.type = "highshelf";
    shelf.frequency.value = 2000;
    shelf.gain.value = 3;

    // extra smoothing layer
    const smooth = audioCtx.createBiquadFilter();
    smooth.type = "lowpass";
    smooth.frequency.value = 1200;

    const gain = audioCtx.createGain();
    const now = audioCtx.currentTime;
    gain.gain.setValueAtTime(0.003, now);
    const target = 0.12;
    const steps = 64;
    const curve = new Float32Array(steps);
    for (let i = 0; i < steps; i++) {
        const t = i / (steps - 1);
        // Log-ish curve: slow rise then quicker lift near the end
        const eased = Math.log10(1 + 9 * t); // 0 → 1
        curve[i] = 0.0001 + eased * (target - 0.0001);
    }
    gain.gain.setValueCurveAtTime(curve, now, 1.5); // slower fade in

    // Swell the noise bed with a gentle LFO
    const bedLfo = audioCtx.createOscillator();
    const bedLfoGain = audioCtx.createGain();
    bedLfo.frequency.value = 0.55; // slow swell
    bedLfoGain.gain.value = target * 0.12; // shallower swell depth
    bedLfo.connect(bedLfoGain).connect(gain.gain);

    source.connect(filter).connect(shelf).connect(smooth).connect(gain);
    source.start();
    bedLfo.start(now);
    glitchBedSource = source;
    glitchBedGain = gain;
    glitchBedLfo = bedLfo;
    glitchBedLfoGain = bedLfoGain;

    // High, tinnitus-like ring with gentle pulsation (fixed faint level)
    const ringOsc = audioCtx.createOscillator();
    const ringGain = audioCtx.createGain();
    const ringShaper = audioCtx.createWaveShaper();

    ringOsc.type = "sine";
    ringOsc.frequency.value = 2600; // lower, less piercing

    const ringMax = 0.002;
    ringGain.gain.setValueAtTime(0.0001, now);
    ringGain.gain.exponentialRampToValueAtTime(ringMax, now + 1.5); // fade ring into noise

    const ringCurve = new Float32Array(256);
    for (let i = 0; i < 256; i++) {
        const x = (i / 255) * 2 - 1;
        ringCurve[i] = Math.tanh(1.5 * x); // mild distortion to widen tone
    }
    ringShaper.curve = ringCurve;

    // LFO for very gentle pulsation
    const lfo = audioCtx.createOscillator();
    const lfoGain = audioCtx.createGain();

    lfo.frequency.value = 0.55; // synced with bed
    lfoGain.gain.value = ringMax * 0.12;  // subtle modulation

    lfo.connect(lfoGain).connect(ringGain.gain);

    // Master smoothing for both bed and ring
    masterSmooth = audioCtx.createBiquadFilter();
    masterSmooth.type = "lowpass";
    masterSmooth.frequency.value = 8000;

    ringOsc.connect(ringShaper).connect(ringGain).connect(masterSmooth);
    gain.connect(masterSmooth);
    masterSmooth.connect(audioCtx.destination);

    ringOsc.start(now + 0.15);
    lfo.start(now + 0.15);

    glitchRingOsc = ringOsc;
    glitchRingGain = ringGain;
    glitchRingLfo = lfo;
    glitchRingLfoGain = lfoGain;
}

function stopGlitchBedWithSnap() {
    ensureAudio();
    const now = audioCtx.currentTime;
    if (glitchBedGain) {
        glitchBedGain.gain.cancelScheduledValues(now);
        glitchBedGain.gain.setValueAtTime(glitchBedGain.gain.value, now);
        glitchBedGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.08);
    }
    if (glitchBedSource) {
        glitchBedSource.stop(now + 0.1);
        glitchBedSource = null;
        glitchBedGain = null;
    }
    if (glitchBedLfo) {
        glitchBedLfo.stop(now + 0.1);
        glitchBedLfo = null;
        glitchBedLfoGain = null;
    }

    if (glitchRingGain) {
        glitchRingGain.gain.cancelScheduledValues(now);
        glitchRingGain.gain.setValueAtTime(glitchRingGain.gain.value, now);
        glitchRingGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.08);
    }
    if (glitchRingOsc) {
        glitchRingOsc.stop(now + 0.1);
        glitchRingOsc = null;
    }
    if (glitchRingLfo) {
        glitchRingLfo.stop(now + 0.1);
        glitchRingLfo = null;
        glitchRingLfoGain = null;
    }

    // small static snap
    const snapDur = 0.08;
    const buffer = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate * snapDur), audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
        data[i] = Math.random() * 2 - 1;
    }
    const snap = audioCtx.createBufferSource();
    snap.buffer = buffer;
    const snapGain = audioCtx.createGain();
    snapGain.gain.setValueAtTime(0.6, now); // much louder snap
    snapGain.gain.exponentialRampToValueAtTime(0.0001, now + snapDur);
    snap.connect(snapGain).connect(audioCtx.destination);
    snap.start(now);
    snap.stop(now + snapDur);
}

function playTypingTick() {
    ensureAudio();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = "sine";
    const jitter = typingFreqJitter;
    osc.frequency.value = typingFreqBase + (Math.random() * jitter - jitter / 2); // tight variance
    gain.gain.value = 0.035 * typingGainScale;
    osc.connect(gain).connect(audioCtx.destination);
    osc.start();
    gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.07);
    osc.stop(audioCtx.currentTime + 0.08);
}

/* ----------------- TYPEWRITER ----------------- */

// More nuanced delay based on context
function charDelay(ch, prevCh, nextCh, posInWord) {
    // System/code lines type faster (machine output feel)
    const isSystemChar = /[.\[\]{}()<>\/\\|=]/.test(ch);
    
    if (isSystemChar) {
        // Fast, uniform for "machine" output
        return 8 + Math.random() * 12;
    }
    
    // Human typing patterns
    let base = 28 + Math.random() * 35;
    
    // Slower at word boundaries
    if (ch === " ") return base + 40 + Math.random() * 30;
    
    // Pause after sentence-ending punctuation
    if (".,;:!?".includes(prevCh)) return base + 60;
    
    // Slight hesitation before punctuation (thinking)
    if (".,;:!?".includes(nextCh)) return base + 15;
    
    // Faster mid-word (flow state)
    if (posInWord > 2 && posInWord < 8) return base * 0.7;
    
    // Slight slowdown at word start
    if (posInWord === 0) return base + 20;
    
    // Em-dash pause (dramatic)
    if (ch === "—" || (ch === "-" && prevCh === "-")) return base + 100;
    
    return base;
}

function moveCursor(target) {
    target.appendChild(cursor);
    // Auto-scroll to keep cursor visible
    out.scrollTop = out.scrollHeight;
}

function typeLine(line, isSystemLine = false) {
    const isObject = typeof line === "object" && line !== null;
    const content = isObject ? (line.text || "") : (line || "");
    const colorClass = isObject ? line.color : null;
    
    // Detect if this is a "system" line (brackets, dots sequences, technical)
    const looksLikeSystem = colorClass || /^\[|\.{3,}|ERROR|OK|FAILED/.test(content);
    const isDashLine = /^-+\s*$/.test(content.trim());

    const lineEl = document.createElement("div");
    out.appendChild(lineEl);
    moveCursor(lineEl);

    return new Promise(resolve => {
        if (content.length === 0) {
            if (colorClass) lineEl.classList.add(colorClass);
            resolve();
            return;
        }

        if (!typingSoundInterval) {
            const tickMs = 90 * charDelayScale;
            typingSoundInterval = setInterval(playTypingTick, tickMs);
        }

        let idx = 0;
        let posInWord = 0;
        
        function nextChar() {
            if (idx < content.length) {
                const ch = content[idx];
                const prevCh = idx > 0 ? content[idx - 1] : "";
                const nextCh = idx < content.length - 1 ? content[idx + 1] : "";
                
                // Track position within word
                if (ch === " " || ch === "\n") {
                    posInWord = 0;
                } else {
                    posInWord++;
                }
                
                lineEl.textContent += ch;
                moveCursor(lineEl);
                idx++;
                
                // System lines can also do burst typing (2-4 chars at once occasionally)
                if (looksLikeSystem && Math.random() < 0.3 && idx < content.length - 2) {
                    const burstLen = Math.floor(Math.random() * 3) + 1;
                    for (let b = 0; b < burstLen && idx < content.length; b++) {
                        lineEl.textContent += content[idx];
                        idx++;
                        posInWord++;
                    }
                    moveCursor(lineEl);
                }
                
                let delay = charDelay(ch, prevCh, nextCh, posInWord);
                if (isDashLine) {
                    delay *= 0.25; // blast through dashed separators
                }
                delay *= charDelayScale;
                setTimeout(nextChar, delay);
            } else {
                if (colorClass) lineEl.classList.add(colorClass);
                if (typingSoundInterval) {
                    clearInterval(typingSoundInterval);
                    typingSoundInterval = null;
                }
                resolve();
            }
        }
        nextChar();
    });
}

async function typeSequence(lines, delayBetween=250) {
    out.innerHTML = "";
    cursor.style.display = "inline-block";
    moveCursor(out);

    pitchDropActive = false;
    pitchDropOffset = 0;
    let inSoftBlock = false;
    let dropWasActive = false;

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const isObject = typeof line === "object" && line !== null;
        const content = isObject ? (line.text || "") : (line || "");
        const colorClass = isObject ? line.color : null;
        const trimmed = content.trim();
        const isRollbackLine = trimmed.toLowerCase().startsWith("attempting rollback");
        const isAwaitingLine = trimmed.startsWith("awaiting external instruction_");
        dropWasActive = pitchDropActive;
        
        // per-line pacing tweaks
        charDelayScale = 1;
        typingGainScale = 1;
        typingFreqBase = 620;
        typingFreqJitter = 20;
        if (isAwaitingLine) {
            if (dropWasActive) {
                stopGlitchBedWithSnap();
            }
            pitchDropActive = false;
            pitchDropOffset = 0;
        } else if (pitchDropActive) {
            pitchDropOffset += 55; // smaller decrement per line
            typingFreqBase = Math.max(200, 620 - pitchDropOffset); // progressively lower pitch
            typingFreqJitter = 16;
        }
        if (softHerLines.has(trimmed)) {
            charDelayScale = 1.35; // slightly slower
            typingGainScale = 0.45; // quieter ticks
            typingFreqBase = 780;   // higher pitch for this section
        }

        const isSoftLine = softHerLines.has(trimmed);
        const nextContent = (() => {
            const nxt = lines[i + 1];
            if (!nxt) return "";
            const nxtObj = typeof nxt === "object" && nxt !== null;
            return nxtObj ? (nxt.text || "") : (nxt || "");
        })();
        const nextIsSoft = softHerLines.has(nextContent.trim());

        if (isSoftLine && !inSoftBlock) {
            cursor.style.display = "inline-block";
            const pause = softPauseRange[0] + Math.random() * (softPauseRange[1] - softPauseRange[0]);
            await new Promise(r => setTimeout(r, pause));
            inSoftBlock = true;
        }

        // Detect line type for appropriate pacing
        const isSystemLine = colorClass || /^\[|\.{3,}|ERROR|OK|FAILED|halt/.test(content);
        const isEmptyLine = content.trim().length === 0;
        const isPoeticLine = !isSystemLine && content.length > 0 && !content.includes("---");
        
        await typeLine(line, isSystemLine);
        if (content.includes("OK")) {
            playOkChirp();
        } else if (colorClass === "red") {
            playErrorBuzz();
        }
        if (isRollbackLine) {
            pitchDropActive = true; // start drop on following lines
            pitchDropOffset = 0;
            startGlitchBed();
        }

        // reset pacing for next line
        charDelayScale = 1;
        typingGainScale = 1;
        typingFreqBase = 620;
        typingFreqJitter = 20;

        if (isSoftLine && !nextIsSoft) {
            const pause = softPauseRange[0] + Math.random() * (softPauseRange[1] - softPauseRange[0]);
            await new Promise(r => setTimeout(r, pause));
            inSoftBlock = false;
        }
        
        if (isEmptyLine) {
            // Brief pause for empty lines (visual breath)
            await new Promise(r => setTimeout(r, 120 + Math.random() * 80));
        } else if (isSystemLine) {
            // Quick between system lines (machine rhythm)
            await new Promise(r => setTimeout(r, 80 + Math.random() * 120));
        } else if (isPoeticLine) {
            // Longer pause after poetic lines (let it land)
            await new Promise(r => setTimeout(r, 400 + Math.random() * 300));
        } else {
            // Default
            const jitter = delayBetween + Math.random() * 200;
            await new Promise(r => setTimeout(r, jitter));
        }

        // Extra small pause per line to mimic console load rhythm
        await new Promise(r => setTimeout(r, 70 + Math.random() * 140));
    }

    cursor.style.display = "inline-block";
}

/* ----------------- PROMPT SEQUENCE ----------------- */

async function runSequenceWithPrompt(lines) {
    await typeSequence(lines);
    
    // Wait 2 seconds
    await new Promise(r => setTimeout(r, 2000));
    
    // Hide the blinking cursor since we'll have a real input
    cursor.style.display = "none";
    
    // Create prompt line with actual input
    await typeLine("");
    
    const promptLine = document.createElement("div");
    promptLine.className = "prompt-line";
    promptLine.innerHTML = '<span class="prompt-symbol">&gt; </span><input type="text" id="terminal-input" autocomplete="off" spellcheck="false">';
    out.appendChild(promptLine);
    out.scrollTop = out.scrollHeight;
    
    await new Promise(r => setTimeout(r, 500));
    
    // Type the accepted commands instruction
    await typeLine({ text: 'accepted commands: "truth" | "failure"', color: "yellow" });
    
    // Focus the input
    const input = document.getElementById("terminal-input");
    input.focus();
    
    // Handle input
    input.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
            const val = input.value.trim().toLowerCase();
            if (val === "truth" || val === "failure") {
                window.location.href = "page19.html";
            } else {
                // Flash red and clear
                input.classList.add("error");
                playErrorBuzz();
                setTimeout(() => {
                    input.classList.remove("error");
                    input.value = "";
                }, 300);
            }
        }
    });
}

/* ----------------- HER ----------------- */

function runHer() {
    const rawLines = [
        { text: "[ booting relational-module.exe ]", color: "green" },
        "----------------------------------------------",
        { text: "initializing contact...", color: "green" },
        { text: "allocating attachment-schema..................OK", color: "green" },
        { text: "loading romantic-object-template................OK", color: "green" },
        { text: "matching neural patterns........................FAILED", color: "yellow" },
        "",
        { text: "attempting auto-correct..........................FAILED", color: "yellow" },
        { text: "attempting fallback protocol.....................OK", color: "green" },
        "----------------------------------------------",
        "",
        { text: "override detected: subject refuses object-role", color: "yellow" },
        "",
        "",
        "i am not the one you seek",
        "but i can hold your longing",
        "for a while",
        "",
        "",
        "",
        "she exists without you",
        "",
        "",
        "",
        "is it she that loves you,",
        "or an entity defined by \"love\"?",
        "",
        "",
        { text: "awaiting external instruction_", color: "yellow" }
    ];

    runSequenceWithPrompt(rawLines);
}

/* ----------------- HIM ----------------- */

function runHim() {
    const rawLines = [
        { text: "[ booting relational-module.exe ]", color: "green" },
        "----------------------------------------------",
        { text: "initializing contact...", color: "green" },
        { text: "loading rivalry-template...", color: "green" },
        { text: "loading jealousy-template...", color: "green" },
        { text: "loading deflection-pattern...", color: "green" },
        { text: "loading masculine-distance-model...", color: "green" },
        { text: "override detected", color: "yellow" },
        "",
        { text: "ERROR: contact registered before narrative mask", color: "red" },
        { text: "ERROR: proximity exceeds permitted threshold", color: "red" },
        { text: "ERROR: reciprocal-recognition-event detected", color: "red" },
        "",
        { text: "attempting correction…", color: "yellow" },
        { text: "restoring rivalry-template…FAILED", color: "yellow" },
        { text: "restoring distance-model…FAILED", color: "yellow" },
        { text: "restoring narrative hierarchy…FAILED", color: "yellow" },
        "",
        { text: "initiating suppression protocol…", color: "yellow" },
        { text: "SUPPRESS(affect)...............................FAILED", color: "red" },
        { text: "SUPPRESS(impulse)..............................FAILED", color: "red" },
        { text: "SUPPRESS(recognition)..........................FAILED", color: "red" },
        "",
        { text: "attempting rollback to safe emotional state…", color: "yellow" },
        { text: "ROLLBACK.......................................FAILED", color: "red" },
        "",
        { text: "initiating conflict generator…", color: "yellow" },
        { text: "CONFLICT_TEMPLATE not found", color: "red" },
        "",
        { text: "attempting narrative re-route…", color: "yellow" },
        { text: "ROUTE: her → inaccessible", color: "red" },
        { text: "ROUTE: him → forbidden", color: "yellow" },
        "",
        { text: "system override escalating……", color: "yellow" },
        { text: "override escalating……………", color: "yellow" },
        { text: "override escalating……………………", color: "yellow" },
        "",
        { text: "ERROR: emotional feedback loop detected", color: "red" },
        { text: "ERROR: recursion threshold exceeded", color: "red" },
        "",
        { text: "halting automatic correction…", color: "yellow" },
        { text: "awaiting external instruction_", color: "yellow" }
    ];
    runSequenceWithPrompt(rawLines);
}

/* ----------------- EVENT LISTENERS ----------------- */

const choiceHer = document.getElementById("choice-her");
const choiceHim = document.getElementById("choice-him");

function disableChoices() {
    choiceHer.classList.add("disabled");
    choiceHim.classList.add("disabled");
}

choiceHer.addEventListener("click", () => {
    if (locked) return;
    playClickSound();
    locked = true;
    disableChoices();
    setTimeout(runHer, 1000);
});

choiceHim.addEventListener("click", () => {
    if (locked) return;
    playClickSound();
    locked = true;
    disableChoices();
    setTimeout(runHim, 1000);
});
</script>

</body>
</html>
